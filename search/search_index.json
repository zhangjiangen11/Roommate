{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#roommate-procedural-3d-level-builder","title":"Roommate: Procedural 3D Level Builder","text":"<p>Warning! This documentation is still work in progress!</p>"},{"location":"getting_started/core_concepts/","title":"Core Concepts","text":""},{"location":"getting_started/core_concepts/#core-concepts","title":"Core Concepts","text":"<p>The core idea of this plugin to make a level design tool that more sophisticalted than GridMap node and less compled than making levels in quake map editor or making 3d models of levels. Portal 2's level editor is the direct inspiration.</p>"},{"location":"getting_started/core_concepts/#how-it-works","title":"How it works","text":"<p>Space is logically divided by blocks (like in minecraft). These blocks are consist of various number of parts (floor, walls and etc) and these parts are responsible to hold information that later will be used to generate mesh, collision shapes etc.. Initially these blocks doesn't hold any information, but you can add BlocksArea derived nodes to set information. After that, Style derived resources are called. They are changing part information based on the rulesets created by these resources. And After that the plugin will create mesh, collision and etc, based on generated info.</p>"},{"location":"getting_started/first_room/","title":"First Room","text":""},{"location":"getting_started/first_room/#first-room","title":"First Room","text":"<p>Let's see what this plugin can do. Follow these steps to create simple room:</p> <ol> <li> <p>Create empty 3d scene</p> </li> <li> <p>Add RoommateRoot</p> </li> <li> <p>Add RoommateSpace as a child of RoommateRoot</p> </li> <li> <p>Select RoommateRoot</p> </li> <li> <p>Press RoommateRoot's menu button and then press Generate </p> </li> </ol> <p>Ta-Da! Now you have simple room!</p> <p></p> <p>Feel free to move around RoommateSpace, change it size and even add new RoommateSpace nodes.</p>"},{"location":"getting_started/installation/","title":"Installation","text":""},{"location":"getting_started/installation/#installation","title":"Installation","text":"<p>Installation process is no different than any of other godot plugins. There are several options how to do it.</p> <p>Warning</p> <p>Restarting editor after installation is recommended.</p>"},{"location":"getting_started/installation/#installing-via-asset-library","title":"Installing via Asset Library","text":"<ol> <li> <p>Open your godot project</p> </li> <li> <p>Click AssetLib Tab</p> </li> <li> <p>Search 'Roommate'</p> </li> <li> <p>Find Roommate plugin and click it</p> </li> <li> <p>In new window, click Download</p> </li> <li> <p>When it installed, press Install</p> </li> </ol>"},{"location":"getting_started/installation/#intalling-manually","title":"Intalling manually","text":""},{"location":"getting_started/installation/#getting-plugin","title":"Getting plugin","text":""},{"location":"getting_started/installation/#github","title":"Github","text":"<ol> <li> <p>Go to releases page of Roommate plugin</p> </li> <li> <p>Find latest version of the plugin</p> </li> <li> <p>Download zip archive, containing plugin</p> </li> </ol>"},{"location":"getting_started/installation/#asset-store","title":"Asset Store","text":"<ol> <li>Go to asset store page of Roommate plugin</li> <li>Press Download button</li> </ol>"},{"location":"getting_started/installation/#adding-plugin","title":"Adding plugin","text":"<ol> <li> <p>Unpack zip archive</p> </li> <li> <p>Put the addon folder inside root of your project</p> </li> <li> <p>Optionally, put script_templates folder inside root of your project</p> </li> </ol>"},{"location":"getting_started/installation/#enabling-plugin","title":"Enabling plugin","text":"<ol> <li> <p>Click Project &gt; Project Settings...</p> </li> <li> <p>Click Plugins tab</p> </li> <li> <p>Click Enable checkbox at the Roommate plugin</p> </li> </ol>"},{"location":"getting_started/settings/","title":"Settings","text":""},{"location":"nodes/area/","title":"RoommateBlocksArea","text":""},{"location":"nodes/area/#roommateblocksarea","title":"RoommateBlocksArea","text":""},{"location":"nodes/area/#default-block-types-reference","title":"Default Block Types Reference","text":"Slot Id Const btid_nodraw <code>RoommateBlock.NODRAW_TYPE</code> btid_space <code>RoommateBlock.SPACE_TYPE</code> btid_oblique <code>RoommateBlock.OBLIQUE_TYPE</code> btid_out_of_bounds <code>RoommateBlock.OUT_OF_BOUNDS_TYPE</code>"},{"location":"nodes/root/","title":"RoommateRoot","text":""},{"location":"nodes/root/#roommateroot","title":"RoommateRoot","text":""},{"location":"nodes/styler/","title":"Styler","text":""},{"location":"nodes/styler/#styler","title":"Styler","text":""},{"location":"nodes/styler/#blocks-scope","title":"Blocks Scope","text":""},{"location":"non_plugin_setup/creating_models/","title":"Creating models","text":""},{"location":"non_plugin_setup/troubleshooting/","title":"Troubleshooting","text":""},{"location":"styles/creating_styles/","title":"Creating Styles","text":""},{"location":"styles/creating_styles/#creating-styles","title":"Creating Styles","text":"<p>Steps to create new style:</p> <ol> <li> <p>Create new gd script</p> </li> <li> <p>Make it tool script</p> </li> <li> <p>Extend it from RoommateStyleBlocks are selected only inside certain scope. Said scope is computed     by RoommateStyler. RoommateBlocksArea's scope is limited by it's     bounding box. Scope of plain RoommateStyle affect all blocks in     RoommateRoot.</p> </li> <li> <p>Override <code>_build_rulesets</code> function</p> </li> <li> <p>Create new rulesets in this function</p> </li> </ol> <p>For example, code below adds sphere in the center of each block.</p> <pre><code>@tool\nextends RoommateStyle\n\n\nfunc _build_rulesets() -&gt; void:\n    var ruleset := create_ruleset()\n    var block_selector := ruleset.select_all_blocks()\n    var parts_setter := ruleset.select_all_walls()\n\n    var new_mesh := CylinderMesh.new()\n    new_mesh.top_radius = 0\n    new_mesh.bottom_radius = 0.1\n    new_mesh.height = 0.5\n    parts_setter.mesh.override(new_mesh).\n</code></pre> <p>Now you can create new Resource file with this script and set it to Style property of RoommateStyler node.</p> <p>For example, we can set style above to the RoommateSpace (it inherits from RoommateStyler). After clicking Generate button, we can see the result. </p> <p></p>"},{"location":"styles/selecting_blocks/","title":"Selecting Blocks","text":""},{"location":"styles/selecting_blocks/#selecting-blocks","title":"Selecting Blocks","text":"<p>There are several functions in ruleset that are responsible for selecting certain blocks by condition. Blocks selectors are limited by blocks scope.</p>"},{"location":"styles/selecting_blocks/#blocks-selection-functions","title":"Blocks Selection Functions","text":"<p>Let's take this scene, for example, and apply various block selector rules. Selected blocks will be colored red.</p> <p></p> <p>We will be using next style script.</p> <pre><code>@tool\nextends RoommateStyle\n\n\nfunc _build_rulesets() -&gt; void:\n    var ruleset := create_ruleset()\n    # block selection code goes here\n    ruleset.select_all_parts().surfaces.color.accumulate(Color.RED, 0.8)\n</code></pre>"},{"location":"styles/selecting_blocks/#select_all_blocks","title":"select_all_blocks","text":"<p>Simply selects all blocks in the scope.</p> <pre><code>ruleset.select_all_blocks()\n</code></pre> <p></p>"},{"location":"styles/selecting_blocks/#select_blocks_by_type","title":"select_blocks_by_type","text":"<p>Select all blocks of certain type. For example, we will select all oblique blocks.</p> <pre><code>ruleset.select_blocks_by_type(RoommateBlock.OBLIQUE_TYPE)\n</code></pre> <p></p>"},{"location":"styles/selecting_blocks/#select_blocks_by_extreme","title":"select_blocks_by_extreme","text":"<p>Select blocks by extreme positions in current scope. </p> <pre><code>ruleset.select_blocks_by_extreme(Vector3i.FORWARD)\n</code></pre> <p></p> <p>If you pass 0 as a value for certain axis, it will be ignored, ie selection will be extruded along that axis. Number means how much rows will be selected from min/max positions. </p> <pre><code>ruleset.select_blocks_by_extreme(Vector3i(2, 0, -1))\n</code></pre> <p></p>"},{"location":"styles/selecting_blocks/#select_edge_blocks","title":"select_edge_blocks","text":"<p>Block is selected if it's near edge. You pass <code>RoommateSegment</code> object to <code>select_edge_blocks</code> </p> <pre><code>var segment_left := RoommateSegment.new(Vector3i.LEFT, 0)\nruleset.select_edge_blocks([segment_left])\n</code></pre> <p></p> <p>You can change <code>max_steps</code> parameter, </p> <pre><code>var segment_left := RoommateSegment.new(Vector3i.LEFT, 1)\nruleset.select_edge_blocks([segment_left])\n</code></pre> <p></p> <p>If you pass multiple segments, block is selected if both of them are satisfied.</p> <pre><code>var segment_left := RoommateSegment.new(Vector3i.LEFT, 0)\nvar segment_down := RoommateSegment.new(Vector3i.DOWN, 0)\nruleset.select_edge_blocks([segment_left, segment_down])\n</code></pre> <p></p> <p>There are <code>select_edge_blocks_axis</code> function. It produces same result as above example</p> <pre><code>ruleset.select_edge_blocks_axis(Vector3i(-1, -1, 0))\n</code></pre>"},{"location":"styles/selecting_blocks/#select_interval_blocks","title":"select_interval_blocks","text":"<p>You can select blocks by interval.</p> <pre><code>ruleset.select_interval_blocks(Vector3i(2, 0, 0))\n</code></pre> <p></p> <p>a</p> <pre><code>ruleset.select_interval_blocks(Vector3i(2, 3, 0))\n</code></pre> <p></p>"},{"location":"styles/selecting_blocks/#select_inner_blocks","title":"select_inner_blocks","text":"<p>a</p> <pre><code>var segment_forward := RoommateSegment.new(Vector3.FORWARD, 0)\nruleset.select_inner_blocks([segment_forward])\n</code></pre> <p></p> <p>a</p> <pre><code>var segment_forward := RoommateSegment.new(Vector3.FORWARD, 1)\nruleset.select_inner_blocks([segment_forward])\n</code></pre> <p></p> <p>a</p> <pre><code>var segment_forward := RoommateSegment.new(Vector3.FORWARD, 0)\nvar segment_up := RoommateSegment.new(Vector3.UP, 0)\nruleset.select_inner_blocks([segment_forward, segment_up])\n</code></pre> <p></p> <p>a</p> <pre><code>ruleset.select_inner_blocks_uniform([Vector3i.FORWARD, Vector3i.UP], 0)\n</code></pre> <pre><code>ruleset.select_inner_blocks_axis(Vector3i(0, 1, -1))\n</code></pre>"},{"location":"styles/selecting_blocks/#select_random_blocks","title":"select_random_blocks","text":"<p>a</p> <pre><code>var rng := RandomNumberGenerator.new()\nrng.seed = hash(\"Roommate is cool!\")\nruleset.select_random_blocks(0.4, rng)\n</code></pre> <p></p> <p>a</p>"},{"location":"styles/selecting_blocks/#select_blocks","title":"select_blocks","text":"<p>a</p> <pre><code>var prepare := func (blocks_scope: Dictionary) -&gt; Dictionary:\n    var max_y: float = NAN\n    var min_y: float = NAN\n    for block_position in blocks_scope:\n        max_y = maxf(max_y, block_position.y)\n        min_y = minf(min_y, block_position.y)\n    return { \"sin_center\": roundi((max_y - min_y) / 2 + min_y) }\n\nvar is_block_selected := func (offset_position: Vector3i, block: RoommateBlock,\n        blocks_scope: Dictionary, prepared_vars: Dictionary) -&gt; bool:\n    var sin_center := prepared_vars[\"sin_center\"] as int\n    return (roundi(sin(offset_position.x)) + sin_center) == offset_position.y\n\nruleset.select_blocks(is_block_selected, prepare)\n</code></pre> <p></p>"},{"location":"styles/selecting_blocks/#blocks-selector-inclusion-modes","title":"Blocks Selector Inclusion modes","text":"<p>asd</p> <pre><code>@tool\nextends RoommateStyle\n\n\nfunc _build_rulesets() -&gt; void:\n    var ruleset := create_ruleset()\n    ruleset.select_blocks_by_extreme(Vector3(0, -1, -1))\n    ruleset.select_blocks_by_extreme(Vector3(0, -1, 1))\n    var selector := ruleset.select_blocks_by_extreme(Vector3(1, -1, 0))\n    # selector mode changing code goes here\n    ruleset.select_all_parts().surfaces.color.accumulate(Color.RED, 0.8)\n</code></pre> <p></p>"},{"location":"styles/selecting_blocks/#include","title":"include","text":"<p>a</p> <pre><code>selector.include()\n</code></pre> <p>a</p>"},{"location":"styles/selecting_blocks/#exclude","title":"exclude","text":"<p>a</p> <pre><code>selector.exclude()\n</code></pre> <p></p>"},{"location":"styles/selecting_blocks/#invert","title":"invert","text":"<p>a</p> <pre><code>selector.invert()\n</code></pre> <p></p>"},{"location":"styles/selecting_blocks/#intersect","title":"intersect","text":"<p>a</p> <pre><code>selector.intersect()\n</code></pre> <p></p>"},{"location":"styles/selecting_parts/","title":"Selecting Parts","text":""},{"location":"styles/selecting_parts/#selecting-parts","title":"Selecting Parts","text":"<p>You can select parts with the <code>select_parts</code> function and passing array of slot ids. For convinience there is <code>select_part</code> which can select single part of a RoommateBlock. You can also use select function for certain default parts, like <code>select_floor</code>, <code>select_wall_forward</code> and etc.</p> <p>All these part selection functions returns parts setter object. You can change it's property <code>inverse_selection</code> to <code>true</code>, so every part will be selected, except provided.</p>"},{"location":"styles/selecting_parts/#default-parts-reference","title":"Default Parts Reference","text":"Slot Id Select Function Const slid_ceil <code>select_ceil</code> <code>RoommateBlock.Slot.CEIL</code> slid_floor <code>select_floor</code> <code>RoommateBlock.Slot.FLOOR</code> slid_wall_left <code>select_wall_left</code> <code>RoommateBlock.Slot.WALL_LEFT</code> slid_wall_right <code>select_wall_right</code> <code>RoommateBlock.Slot.WALL_RIGHT</code> slid_wall_forward <code>select_wall_forward</code> <code>RoommateBlock.Slot.WALL_FORWARD</code> slid_wall_back <code>select_wall_back</code> <code>RoommateBlock.Slot.WALL_BACK</code> slid_center <code>select_center</code> <code>RoommateBlock.Slot.CENTER</code> slid_oblique <code>select_oblique</code> <code>RoommateBlock.Slot.OBLIQUE</code>"},{"location":"styles/styles_intro/","title":"Introdution To Styles","text":""},{"location":"styles/styles_intro/#introdution-to-styles","title":"Introdution To Styles","text":"<p>RoommateStyle is a resource that can change properties of RoommateParts by certain conditions.</p>"}]}